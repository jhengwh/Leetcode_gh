## 138. Copy List with Random Pointer

### Solution 1: Hash map

- Clear and simple.
- Memory-inefficient.
    - Although the space complexity is also $O(n)$, it uses extra memory to map each node from the original to the copied list.
    - If something similar needed to be done on an **embedded system, use the interleaving approach instead**. Since you don't want the STL making a bunch of heap allocations without your awareness.

(Comments and code are conclude from Leetcode.)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (!head)
            return nullptr;

        unordered_map<Node*, Node*> old_to_new;

        // Build mapping & assign 'val'                // (2)
        Node* curr = head;
        while (curr) {
            old_to_new[curr] = new Node(curr->val);    // (1)
            curr = curr->next;
        }

        // Link the nodes (assign *next & *random)     // (3)
        curr = head;
        while (curr) {
            old_to_new[curr]->next = old_to_new[curr->next];
            old_to_new[curr]->random = old_to_new[curr->random];
            curr = curr->next;
        }

        return old_to_new[head];
    }
};
```

1. 合併以下兩敘述句，使更簡潔：
    
    ```cpp
    Node* new_node = new Node(curr->val);
    old_to_new[curr] = new_node;
    ```
    
2. 在這裡不做link the list（對`*next`賦值）而是留待 3. 再做：當mapping建立好後，可在traverse舊list的同時對新list操作，省去一邊建立一邊traverse新list的困擾。
3. 同上。

<br/>

### Solution 2: **Interweaving Nodes**

- Sleek and space-efficient.
- Space complexity: $O(n)$.

(Comments and code are conclude from Leetcode.)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (!head)
            return nullptr;

        // Interweave old & new nodes
        Node* curr = head;
        while (curr) {
            Node* new_node = new Node(curr->val);
            new_node->next = curr->next;
            curr->next = new_node;
            curr = new_node->next;
        }

        // Assign *random
        curr = head;
        while (curr) {
            if (curr->random)    // (1)
                curr->next->random = curr->random->next;
            curr = curr->next->next;
        }

        // Seperate old & new nodes to two lists
        Node* new_head = head->next;
        Node* curr_old = head;
        Node* curr_new = new_head;
        while (curr_old) {
            curr_old->next = curr_old->next->next;
            curr_new->next = (curr_new->next) ? curr_new->next->next : nullptr;
            curr_old = curr_old->next;
            curr_new = curr_new->next;
        }

        return new_head;
    }
};
```

1. 記得檢查curr的`*random`是否有值，有可能是NULL。